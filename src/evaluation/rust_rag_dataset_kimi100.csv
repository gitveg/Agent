id,question,context
1,alloc crate 的主要设计目标是什么,"alloc 为 #![no_std] 环境提供堆分配能力，包含 Box、Vec、Arc 等智能指针与集合，内容由 std 重新导出。"
2,Box<T> 的所有权语义如何,"Box 是单所有者堆智能指针，大小等于一个指针，可跨线程移动，常用于构建树形结构。"
3,Rc 与 Arc 的核心差异,"Rc 仅用于单线程共享，Arc 通过原子引用计数实现线程安全，二者 API 一致但 Arc 要求 T: Send + Sync。"
4,core::panic::PanicInfo 入参包含哪些字段,"PanicInfo 携带 panic 位置、消息与 Payload，用户通过 #[panic_handler] 函数接收并处理。"
5,proc_macro crate 的 quote! 宏作用,"quote! 将手写 Rust 代码片段转换为 TokenStream，方便在过程宏中生成新代码。"
6,std::collections::HashMap 与 BTreeMap 选型差异,"HashMap 平均 O(1) 查询但无序，BTreeMap 保持键有序且支持范围查询，权衡速度 vs 顺序。"
7,test::black_box 为何能防止编译器优化,"black_box 将参数标记为“不透明副作用”，强制编译器假设其值会被使用，避免常量折叠与死码消除。"
8,Vec<T> 的底层内存布局,"Vec 由 ptr+cap+len 组成，ptr 指向堆上连续 T，保证与 slice [T] 布局兼容。"
9,core 库为何完全不依赖堆,"core 定位为平台无关的底层基础，不负责分配、I/O、并发，仅提供语言原语与内存工具，因此链接 0 个系统库。"
10,Arc<Mutex<T>> 常见使用模式,"先 Arc::new(Mutex::new(val)) 共享所有权，再 clone Arc 给多线程，lock() 后获得 MutexGuard 进行互斥访问。"
11,alloc::format! 与 core::format_args! 关系,"format! 在 alloc 中基于 format_args! 生成 String，core 只生成 fmt::Arguments，不分配堆内存。"
12,std::thread::spawn 对闭包的 Send 约束,"spawn 要求闭包 F: Send + 'static，确保捕获变量可跨线程传递且生命周期贯穿线程运行期。"
13,proc_macro::TokenTree 的三种变体,"TokenTree 可以是 Group（括号包裹）、Ident（标识符）、Punct（标点）、Literal（字面量）四种。"
14,core::mem::size_of 在 const fn 中的稳定性,"1.32 起 size_of 成为 const fn，可在编译期计算大小，用于静态数组或 const 泛型约束。"
15,#[global_allocator] 与 alloc 模块交互,"global_allocator 将用户自定义分配器注册为 alloc 全局代理，Box/Vec 等默认使用该实例。"
16,std::env::args() 与 args_os() 差异,"args() 返回 UTF-8 String 迭代器，args_os() 返回 OsString，避免非法 Unicode 导致 panic。"
17,test crate 为何仅限 nightly,"test 提供 Bencher 与内部运行时挂钩，接口未稳定，因此 stable 通道无法引入。"
18,Cell<T> 的 UnsafeCell 内部实现,"Cell 包裹 UnsafeCell，通过禁用 &T 共享引用实现内部可变性，仅适用于 Copy 类型。"
19,alloc::collections::BTreeSet 的底层数据结构,"基于 B-Tree 实现，节点保存有序键切片，支持二分查找与范围迭代。"
20,core::arch 模块用途,"提供平台相关 SIMD 内联函数，如 x86::_mm_add_ps，需在 unsafe 块中调用。"
21,std::fs::read_to_string 一次读取策略,"内部调用 read_to_end 把文件全部读入 Vec<u8>，再经 UTF-8 验证后转为 String，适合小文件。"
22,quote!(#(#vec),*) 中的重复语法,"#( ... ),* 为 quote 重复插值，vec 迭代元素按逗号连接展开，常用于生成变长参数列表。"
23,Arc::downgrade 产生的 Weak 引用行为,"Weak 不增加强引用计数，upgrade() 返回 Option<Arc>，可检测对象是否已被释放。"
24,core::slice::from_raw_parts 的安全前提,"指针必须非 null、对齐且覆盖 len 个合法 T，违反则产生 UB，常与 C 接口交互。"
25,std::process::Command 搜索可执行文件顺序,"先在当前目录查找，再按 PATH 环境变量顺序搜索，与平台 shell 一致。"
26,alloc::vec! 宏与 Vec::new 性能差异,"vec![x; n] 预分配容量并一次性写入，比重复 push 减少重分配，适合已知长度场景。"
27,std::backtrace::Backtrace 捕获时机,"Backtrace::capture() 在调用点立即遍历栈帧，支持符号化，需启用 RUST_BACKTRACE=1 查看。"
28,core::cmp::Reverse 作用,"Reverse 包装任意 Ord 类型，反转 compare 结果，常用于最大堆或逆序排序。"
29,proc_macro::Literal 如何保持 span 信息,"Literal 携带 Span，错误时可定位到宏展开位置，调试器与编译器诊断据此高亮。"
30,std::time::SystemTime 与 Instant 区别,"SystemTime 可回退且跨系统重启，Instant 仅保证单调递增，适合测量耗时。"
31,alloc::String::from_utf8_unchecked 安全责任,"调用者须保证 Vec<u8> 为合法 UTF-8，否则产生未定义行为，常用于已知有效的解析路径。"
32,core::panic::panic! 与 std::panic! 差异,"core 版仅接收 fmt 参数，std 版可捕获 Backtrace 并调用用户钩子，功能更丰富。"
33,std::collections::VecDeque 环形缓冲区实现,"使用双指针 head/tail 与掩码实现环形索引，保证 O(1) 头尾插入与弹出。"
34,test::Bencher::iter 测量方式,"iter 接收闭包并执行多次，自动计算迭代次数与耗时，结果以 ns/iter 输出。"
35,Box<[T]> 与 Vec<T> 内存占用对比,"Box<[T]> 无容量字段，仅 ptr+len，不可增长，比 Vec 节省一个 usize，适合只读快照。"
36,core::str::from_utf8 错误类型,"返回 Result<&str, Utf8Error>，Utf8Error 携带无效字节位置与长度，便于精确报错。"
37,std::net::TcpStream::set_nodelay 作用,"禁用 Nagle 算法，降低小包延迟，适用于实时游戏或交互式协议。"
38,alloc::Rc::make_mut 优化写时复制,"若强引用为 1 则直接获取 &mut T，否则克隆底层数据，减少不必要拷贝。"
39,core::future::Future 的 poll 签名,"fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Output>，必须线程安全且不回 block。"
40,std::thread::park 与 unpark 配对,"park 阻塞当前线程，unpark 在其他线程调用，实现轻量级等待/通知，常用于 channel 内部。"
41,proc_macro::Group::delimiter() 返回枚举,"Delimiter::{Parenthesis, Brace, Bracket}，对应 ( ) { } [ ]，帮助解析宏结构。"
42,alloc::collections::LinkedList 为何常不推荐使用,"缓存局部性差且每次分配节点，VecDeque 在多数场景更优，仅当需要常数时间拼接才考虑。"
43,core::hint::unreachable_unchecked 安全契约,"编译器假设该路径永不执行，可触发优化，若实际到达则 UB，用于性能极致场景。"
44,std::env::var_os 避免 panic 策略,"返回 Option<OsString>，若变量不存在或包含非法 Unicode 不会 panic，与 var() 区分。"
45,Arc::new 在编译期的常量评估,"Arc::new 非 const fn，因需堆分配，故无法在 const 上下文中创建 Arc。"
46,core::iter::Iterator::size_hint 作用,"返回 (lower, Option<upper>) 估计长度，优化 Vec::collect() 预分配，避免多次扩容。"
47,std::fs::hard_link 跨平台限制,"Windows 要求源与目标在同一盘符，Unix 允许同一文件系统，失败返回 io::Error。"
48,alloc::format! 与 println! 宏本质差异,"format! 返回 String，println! 写入标准输出并追加换行，二者共享同一 fmt 机制。"
49,test::assert_test_result 用途,"将测试闭包返回 Result<(), E> 转为 panic，支持 ? 在 #[test] 函数中传播错误。"
50,core::mem::forget 安全影响,"forget 放弃调用 Drop，内存泄漏但无 UB，常用于 FFI 把所有权交给外部代码。"
51,std::collections::HashSet 基于 HashMap 实现,"内部使用 HashMap<T, ()>，仅保留键，复用哈希表代码，提供 O(1) 去重。"
52,Box::leak 转换到 'static 引用,"消耗 Box 并返回 &mut T，生命周期 'static，常用于配置全局单例或 FFI 传出指针。"
53,proc_macro::Span::mixed_site  hygiene 级别,"mixed_site 介于 call_site 与 def_site，宏内标识符解析遵循定义处作用域，实验性。"
54,core::num::NonZeroU32 优化布尔检查,"包装非零值，Option<NonZeroU32> 与裸 u32 同大小，减少分支提升性能。"
55,std::io::BufRead::lines 迭代器注意点,"每次读取会分配新 String，高性能场景建议复用缓冲区手动 split。"
56,alloc::Vec::retain 筛选算法,"双指针原地移除，满足条件的元素前移，O(n) 且仅触发一次内存复制。"
57,std::process::exit 立即终止副作用,"不运行析构函数，缓冲区未刷新，建议优先用 Result 传播或 drop 后返回。"
58,core::slice::sort 采用何种算法,"对短序列用插入排序，长序列用 pattern-defeating quicksort，保证 O(n log n) 且避免最坏退化。"
59,Arc::strong_count 返回 usize,"实时获取强引用数量，用于调试或写断言，但需小心竞态仅作参考。"
60,std::net::Ipv6Addr::loopback 常量,"定义 ::1，与 IPv4 127.0.0.1 对应，网络编程常用作本地测试地址。"
61,alloc::String::shrink_to_fit 可能触发重分配,"若当前容量大于 len，调用 realloc 缩小缓冲区，节省内存但使所有引用失效。"
62,core::str::as_bytes 零成本转换,"返回 &[u8] 与原 str 同地址，无分配，用于与 C 或二进制接口交互。"
63,std::thread::yield_now 协作式调度,"主动放弃时间片，让调度器切换，减少忙等 CPU 占用，不保证立刻切换。"
64,test::bench::black_box 参数类型,"接收 T 并返回 T，内部使用汇编屏障，适用于任何 Copy/non-Copy 值。"
65,Box<dyn Trait> 胖指针布局,"两个 usize：数据指针 + vtable 指针，大小固定，允许在集合中存储异质对象。"
66,core::cell::RefCell::borrow_mut 运行时检查,"维护读写计数，违反借用规则立即 panic，代替编译期检查实现内部可变性。"
67,std::fs::create_dir_all 递归创建,"逐层创建父目录，已存在则跳过，返回 io::Result，用于初始化数据目录。"
68,alloc::collections::BinaryHeap 存储方式,"基于 Vec 的隐式二叉堆，索引 0 为根，父子关系通过位运算计算，缓存友好。"
69,proc_macro::Literal::u32_unsuffixed 生成无后缀数字,"产生的字面量不带 u32 后缀，适用于上下文可推断类型，保持代码简洁。"
70,core::ops::Drop 唯一方法签名,"fn drop(&mut self)，不允许显式调用，由编译器插入，用于释放资源。"
71,std::panic::catch_unwind 捕获条件,"仅对 UnwindSafe 闭包有效，若 panic 使用 abort 策略则无法捕获，常用于 FFI 边界隔离。"
72,Vec::into_raw_parts 获取底层三件套,"返回 (*mut T, length, capacity)，把所有权交给调用者，配合 from_raw_parts 重建。"
73,core::arch::wasm32::unreachable,"WebAssembly 专用内联函数，立即触发 unreachable 指令，用于代码体积优化。"
74,std::env::set_var 线程安全注意,"修改环境变量可能触发 libc 锁，与 fork/exec 并发时易死锁，推荐最小化使用。"
75,alloc::Rc::weak_count 返回当前弱引用数量,"用于诊断循环引用，但值可能在返回后立即变化，仅作调试参考。"
76,core::future::poll_fn 适配自由函数,"将 fn(cx) -> Poll 转换为实现 Future 的匿名类型，简化手写 future。"
77,std::io::copy 默认缓冲区大小,"使用 8 KiB 栈缓冲区，可通过 copy_buf 自定义，适合大文件流式传输。"
78,Box::pin 与 Pin<Box<T>> 关系,"Box::pin 在堆上固定值，返回 Pin<Box<T>>，保证之后无法移动，用于异步自引用结构。"
79,proc_macro::TokenStream 与 quote! 互转,"quote! 生成 TokenStream，parse::<TokenStream>() 可把字符串反向解析，实现宏间拼接。"
80,core::slice::chunks_exact 返回长度,"返回 ChunksExact，最后不足 chunk 的部分通过 remainder() 单独获取，避免边界检查。"
81,std::time::Duration::as_millis 返回类型,"返回 u128，保证即使 584 年跨度也能精确表示毫秒，无溢出风险。"
82,alloc::String::replace 算法复杂度,"单次扫描，替换段使用 Vec<u8> 累积，最坏 O(n+m) 其中 m 为替换后总长度。"
83,std::net::SocketAddr 的枚举结构,"SocketAddr::V4 包含 Ipv4Addr + u16 端口，SocketAddr::V6 额外含 flowinfo 与 scope_id。"
84,core::mem::swap 不依赖 Drop,"仅按位交换，若 T 无 Drop 则内联为三条 memcpy，零成本抽象。"
85,Arc::ptr_eq 比较逻辑,"比较两个 Arc 的底层指针而非值，忽略引用计数，用于检测是否指向同一分配。"
86,std::fs::metadata 不跟随符号链接,"使用 symlink_metadata 可获取链接本身信息，metadata 默认跟随。"
87,alloc::collections::VecDeque::make_contiguous 作用,"把环形缓冲区压缩为连续切片，返回 &mut [T]，后续可零成本随机访问。"
88,core::str::trim_matches 闭包谓词,"接收 fn(char) -> bool，可自定义字符类，比固定空格 trim 更灵活。"
89,std::process::Command::output 行为,"继承父进程 stdout/stderr 为 piped，等待子进程结束，返回 Result<Output> 含状态与输出。"
90,test::stats::Summary 提供的统计,"包含 min/max/mean/std_dev，用于 Bencher 自动生成五次运行的性能摘要。"
91,Box<[T]> 从 Vec<T> 转换成本,"Vec::into_boxed_slice 调用 realloc 收缩到确切长度，仅一次分配，后续不可增长。"
92,core::cell::UnsafeCell::get 返回 *mut T,"放弃借用检查，调用者需保证互斥访问，是 RefCell 与 Mutex 的基础原语。"
93,std::io::stdin 锁自动释放,"StdinLock 实现 Drop，离开作用域即解锁，允许同一线程多次锁定而不死锁。"
94,alloc::format_args! 可嵌套,"返回 fmt::Arguments，可再传给 format! 或 writeln!，实现零分配链式格式化。"
95,proc_macro::Delimiter::None 含义,"表示隐形分隔，例如 $:ident 匹配后不产生括号，用于保持标记流平坦。"
96,core::hint::spin_loop 平台优化,"在 x86 生成 PAUSE 指令，降低功耗并提升超线程效率，用于自旋锁等待。"
97,std::path::Path::join 替换分隔符,"按平台规则插入 / 或 \，消除重复分隔符，返回新的 PathBuf，不修改原路径。"
98,Arc::default 不会分配,"仅当 T: Default 时生成 Arc::new(T::default())，第一次克隆才实际堆分配。"
99,alloc::collections::LinkedList::append 复杂度,"拼接操作为 O(1)，仅调整头尾指针，不遍历节点，适合双队列合并。"
100,core::slice::binary_search 返回值,"Result<usize, usize>，Ok 表示找到位置，Err 插入点，保证序列必须有序。"